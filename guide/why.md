---
title: 为什么是 Vitest | 指南
---

# 为什么是 Vitest

:::tip 提示
该文档假设你是熟悉 Vite 的。开始阅读之前建议先浏览 [为什么选 Vite](https://cn.vitejs.dev/guide/why.html) 和 [下一代前端工具 ViteJS](https://www.bilibili.com/video/BV1kh411Q7WN) ，在视频中 [尤雨溪](https://bsky.app/profile/evanyou.me) 做了一个示范来解释 Vite 的主要概念。
:::

## Vite 原生测试运行器的必要性

Vite 天然支持常见的 Web 模式，同时支持 glob 导入和 SSR 等功能，而且它拥有许多插件和集成框架，从而慢慢形成一个活跃的生态社区。它的开发和构建模式是其成功的关键。对于文档构建框架，Vite 提供了一些基于 SSG 的替代方案。但是 Vite 的单元测试形式还不是十分清晰，而对于目前一些现有方案，比如 [Jest](https://jestjs.io/zh-Hans/) 而言，它们会在不同的上下文环境中被创建的。并且 Jest 和 Vite 之间有很多重复的部分，让用户不得不创建两个不同的配置文件。

使用 Vite 开发服务器在测试过程中对文件进行转换，使得创建一个简单的测试运行器变得更加容易。该测试运行器无需处理源文件转换的复杂性，只需专注于提供最佳的开发体验。Vitest 与你的应用使用相同的配置（通过 `vite.config.js` ），在开发、构建和测试过程中共享相同的转换流水线。它还提供了可扩展的插件 API ，让你和你的工具维护者能够与 Vite 进行一流的集成。Vitest 从一开始就考虑了与 Vite 的协同工作，充分利用了 Vite 在开发体验方面的改进，如即时的热模块重载（ HMR ）。这就是 Vitest ，一个由 Vite 驱动的下一代测试框架。

由于 Jest 的大规模使用，Vitest 提供了与之兼容的 API，允许大家在大多数项目中将其作为备选使用。同时还包括了单元测试时最常见的功能（模拟，快照以及覆盖率）。Vitest 非常注重性能，尽可能多地使用 Worker 线程进行并发运行。并且在一些端口的测试运行速度提高了一个数量级。监听模式默认启用，与 Vite 推动开发者优先体验的理念保持一致。 即使在开发体验上进行了改进，Vitest 通过仔细挑选其依赖项（或直接内联所需的部分）来保持轻量级。

**Vitest 旨在将自己定位为 Vite 项目的首选测试框架，即使对于不使用 Vite 的项目也是一个可靠的替代方案。**

继续阅读 [快速起步](./index)

## Vitest 与 X 有何不同？

你可以查看 [比较](./comparisons) 部分，了解有关 Vitest 与其他类似工具有何不同的更多详细信息。
