import{_ as e,o as d,i as o,R as r}from"./chunks/framework.XDTXXE-5.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/cli-table.md","filePath":"guide/cli-table.md","lastUpdated":1771601921000}'),c={name:"guide/cli-table.md"};function s(a,t,l,n,i,u){return d(),o("div",null,[...t[0]||(t[0]=[r('<table tabindex="0"><thead><tr><th>选项</th><th></th></tr></thead><tbody><tr><td><code>-r, --root &lt;path&gt;</code></td><td>根路径</td></tr><tr><td><code>-c, --config &lt;path&gt;</code></td><td>配置文件的路径</td></tr><tr><td><code>-u, --update</code></td><td>更新快照</td></tr><tr><td><code>-w, --watch</code></td><td>启用 watch 模式</td></tr><tr><td><code>-t, --testNamePattern &lt;pattern&gt;</code></td><td>使用符合指定 regexp 模式的全名运行测试</td></tr><tr><td><code>--dir &lt;path&gt;</code></td><td>扫描测试文件的基本目录</td></tr><tr><td><code>--ui</code></td><td>启用用户界面</td></tr><tr><td><code>--open</code></td><td>自动打开用户界面 (默认: <code>!process.env.CI</code>)</td></tr><tr><td><code>--api.port [port]</code></td><td>自动打开用户界面指定服务器端口。请注意，如果端口已被使用，Vite 会自动尝试下一个可用端口，因此这可能不是服务器最终监听的实际端口。如果为 &quot;true&quot;，将设置为 <code>51204</code></td></tr><tr><td><code>--api.host [host]</code></td><td>指定服务器应该监听哪些 IP 地址。设为 <code>0.0.0.0</code> 或 <code>true</code> 则监听所有地址，包括局域网地址和公共地址</td></tr><tr><td><code>--api.strictPort</code></td><td>设置为 true 时，如果端口已被使用，则退出，而不是自动尝试下一个可用端口</td></tr><tr><td><code>--silent</code></td><td>测试控制台输出</td></tr><tr><td><code>--hideSkippedTests</code></td><td>隐藏跳过测试的日志</td></tr><tr><td><code>--reporter &lt;name&gt;</code></td><td>指定报告</td></tr><tr><td><code>--outputFile &lt;filename/-s&gt;</code></td><td>如果还指定了支持报告程序，则将测试结果写入文件，使用 cac 的点符号表示多个报告程序的单个输出结果 (比如: --outputFile.tap=./tap.txt)</td></tr><tr><td><code>--coverage.all</code></td><td>是否在报告中包含所有文件，包括未测试的文件</td></tr><tr><td><code>--coverage.provider &lt;name&gt;</code></td><td>选择覆盖范围采集工具，可用值为 &quot;V8&quot;、&quot;istanbul&quot;和 &quot;custom&quot;。</td></tr><tr><td><code>--coverage.enabled</code></td><td>启用覆盖范围收集。可使用 <code>--coverage</code> CLI 选项覆盖（默认值：<code>false</code>）。</td></tr><tr><td><code>--coverage.include &lt;pattern&gt;</code></td><td>作为 glob 模式包含在覆盖范围内的文件。使用多个模式时，可指定多次（默认值：<code>**</code>）。</td></tr><tr><td><code>--coverage.exclude &lt;pattern&gt;</code></td><td>覆盖范围中要排除的文件。使用多个扩展名时，可指定多次（默认情况下： 访问 <a href="https://vitest.dev/config/#coverage-exclude" target="_blank" rel="noreferrer"><code>coverage.exclude</code></a></td></tr><tr><td><code>--coverage.extension &lt;extension&gt;</code></td><td>包含在覆盖范围内的扩展名。使用多个扩展名时，可指定多次 (默认: <code>[&quot;.js&quot;, &quot;.cjs&quot;, &quot;.mjs&quot;, &quot;.ts&quot;, &quot;.mts&quot;, &quot;.tsx&quot;, &quot;.jsx&quot;, &quot;.vue&quot;, &quot;.svelte&quot;]</code>)</td></tr><tr><td><code>--coverage.clean</code></td><td>运行测试前清除覆盖结果（默认值：true）</td></tr><tr><td><code>--coverage.cleanOnRerun</code></td><td>重新运行监视时清理覆盖率报告（默认值：true）</td></tr><tr><td><code>--coverage.reportsDirectory &lt;path&gt;</code></td><td>将覆盖率报告写入的目录（默认值： ./coverage）</td></tr><tr><td><code>--coverage.reporter &lt;name&gt;</code></td><td>使用的报告。更多信息请访问 <a href="https://vitest.dev/config/#coverage-reporter" target="_blank" rel="noreferrer"><code>coverage.reporter</code></a>。 (默认值: <code>[&quot;text&quot;, &quot;html&quot;, &quot;clover&quot;, &quot;json&quot;]</code>)</td></tr><tr><td><code>--coverage.reportOnFailure</code></td><td>即使测试失败也能生成覆盖率报告 (默认值: <code>false</code>)</td></tr><tr><td><code>--coverage.allowExternal</code></td><td>收集项目根目录外文件的覆盖范围（默认值：<code>false</code>）</td></tr><tr><td><code>--coverage.skipFull</code></td><td>不显示语句、分支和函数覆盖率为 100% 的文件（默认值：<code>false</code>）</td></tr><tr><td><code>--coverage.thresholds.100</code></td><td>将所有覆盖率阈值设置为 100 的快捷方式（默认值：<code>false</code>）</td></tr><tr><td><code>--coverage.thresholds.perFile</code></td><td>检查每个文件的阈值。 <code>--coverage.thresholds.lines</code>, <code>--coverage.thresholds.functions</code>, <code>--coverage.thresholds.branches</code>, <code>--coverage.thresholds.statements</code> 为实际阈值（默认值：<code>false</code>）</td></tr><tr><td><code>--coverage.thresholds.autoUpdate</code></td><td>更新阈值： 当当前覆盖率高于配置的阈值时，将 &quot;lines&quot;、&quot;functions&quot;、&quot;branches&quot;和 &quot;statements&quot;更新到配置文件（默认值：<code>false</code>）</td></tr><tr><td><code>--coverage.thresholds.lines &lt;number&gt;</code></td><td>针对代码行的覆盖度阈值设定，请访问 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds" target="_blank" rel="noreferrer">istanbuljs</a> 了解更多信息。此选项不适用于自定义 providers</td></tr><tr><td><code>--coverage.thresholds.functions &lt;number&gt;</code></td><td>针对函数的覆盖度阈值设定，请访问 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds" target="_blank" rel="noreferrer">istanbuljs</a> 了解更多信息。 此选项不适用于自定义 providers</td></tr><tr><td><code>--coverage.thresholds.branches &lt;number&gt;</code></td><td>针对 branches 的覆盖度阈值设定，请访问 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds" target="_blank" rel="noreferrer">istanbuljs</a> 了解更多信息。 此选项不适用于自定义 providers</td></tr><tr><td><code>--coverage.thresholds.statements &lt;number&gt;</code></td><td>针对 statements 的覆盖度阈值设定，请访问 <a href="https://github.com/istanbuljs/nyc#coverage-thresholds" target="_blank" rel="noreferrer">istanbuljs</a> 了解更多信息。 此选项不适用于自定义 providers</td></tr><tr><td><code>--coverage.ignoreClassMethods &lt;name&gt;</code></td><td>覆盖时要忽略的类方法名称数组。更多信息请访问 <a href="https://github.com/istanbuljs/nyc#ignoring-methods" target="_blank" rel="noreferrer">istanbuljs</a> 。该选项仅适用于 istanbul providers（默认值：<code>[]</code>）。</td></tr><tr><td><code>--coverage.processingConcurrency &lt;number&gt;</code></td><td>处理覆盖率结果时使用的并发限制。 （默认最小值介于 20 和 CPU 数量之间）</td></tr><tr><td><code>--coverage.customProviderModule &lt;path&gt;</code></td><td>指定自定义覆盖范围提供程序模块的模块名称或路径。 请访问<a href="https://vitest.dev/guide/coverage#custom-coverage-provider" target="_blank" rel="noreferrer">自定义 providers 覆盖范围</a> 了解更多信息。 此选项仅适用于自定义 providers</td></tr><tr><td><code>--coverage.watermarks.statements &lt;watermarks&gt;</code></td><td>High and low watermarks for statements in the format of <code>&lt;high&gt;,&lt;low&gt;</code></td></tr><tr><td><code>--coverage.watermarks.lines &lt;watermarks&gt;</code></td><td>High and low watermarks for lines in the format of <code>&lt;high&gt;,&lt;low&gt;</code></td></tr><tr><td><code>--coverage.watermarks.branches &lt;watermarks&gt;</code></td><td>High and low watermarks for branches in the format of <code>&lt;high&gt;,&lt;low&gt;</code></td></tr><tr><td><code>--coverage.watermarks.functions &lt;watermarks&gt;</code></td><td>High and low watermarks for functions in the format of <code>&lt;high&gt;,&lt;low&gt;</code></td></tr><tr><td><code>--mode &lt;name&gt;</code></td><td>覆盖 Vite 模式 (默认值: <code>test</code> 或 <code>benchmark</code>)</td></tr><tr><td><code>--workspace &lt;path&gt;</code></td><td>工作区配置文件的路径</td></tr><tr><td><code>--isolate</code></td><td>隔离运行每个测试文件。要禁用隔离, 使用 <code>--no-isolate</code> (默认值: <code>true</code>)</td></tr><tr><td><code>--globals</code></td><td>全局注入</td></tr><tr><td><code>--dom</code></td><td>使用 happy-dom 模拟浏览器 API</td></tr><tr><td><code>--browser.enabled</code></td><td>在浏览器中运行测试。 相当于 <code>--browser.enabled</code> (默认值: <code>false</code>)</td></tr><tr><td><code>--browser.name &lt;name&gt;</code></td><td>在特定浏览器中运行所有测试。某些浏览器只适用于特定的 providers (比如 <code>--browser.provider</code>). 通过 <a href="https://vitest.dev/config/#browser-name" target="_blank" rel="noreferrer"><code>browser.name</code></a> 查看更多信息</td></tr><tr><td><code>--browser.headless</code></td><td>在无头模式下运行浏览器（即不打开图形用户界面）。如果在 CI 中运行 Vitest，默认情况下将启用无头模式 (默认值: <code>process.env.CI</code>)</td></tr><tr><td><code>--browser.api.port [port]</code></td><td>指定服务器端口。注意，如果端口已被使用，Vite 会自动尝试下一个可用端口，因此这可能不是服务器最终监听的实际端口。如果为 <code>true</code>，将设置为 <code>63315</code></td></tr><tr><td><code>--browser.api.host [host]</code></td><td>指定服务器应该监听哪些 IP 地址。设为 <code>0.0.0.0</code> 或 <code>true</code> 则监听所有地址，包括局域网地址和公共地址</td></tr><tr><td><code>--browser.api.strictPort</code></td><td>设置为 true 时，如果端口已被使用，则退出，而不是自动尝试下一个可用端口</td></tr><tr><td><code>--browser.provider &lt;name&gt;</code></td><td>用于运行浏览器测试的 Provider。某些浏览器只适用于特定的提供 Provider，可以是&quot;webdriverio&quot;, &quot;playwright&quot;, &quot;preview&quot;，或自定义 provider. 通过 <a href="https://vitest.dev/config/#browser-provider" target="_blank" rel="noreferrer"><code>browser.provider</code></a> 查看更多信息 (默认值: <code>&quot;preview&quot;</code>)</td></tr><tr><td><code>--browser.isolate</code></td><td>隔离运行每个浏览器测试文件。要禁用隔离请使用 <code>--browser.isolate=false</code> (默认值: <code>true</code>)</td></tr><tr><td><code>--browser.ui</code></td><td>运行测试时显示 Vitest UI(默认值: <code>!process.env.CI</code>)</td></tr><tr><td><code>--browser.fileParallelism</code></td><td>浏览器测试文件是否应并行运行。使用 <code>--browser.fileParallelism=false</code> 可禁用 (默认值: <code>true</code>)</td></tr><tr><td><code>--pool &lt;pool&gt;</code></td><td>如果未在浏览器中运行，则指定 pool (默认值: <code>threads</code>)</td></tr><tr><td><code>--poolOptions.threads.isolate</code></td><td>在线程池中隔离测试 (默认值: <code>true</code>)</td></tr><tr><td><code>--poolOptions.threads.singleThread</code></td><td>在单线程内运行测试 (默认值: <code>false</code>)</td></tr><tr><td><code>--poolOptions.threads.maxThreads &lt;workers&gt;</code></td><td>运行测试的最大线程数或百分比</td></tr><tr><td><code>--poolOptions.threads.minThreads &lt;workers&gt;</code></td><td>运行测试的最小线程数或百分比</td></tr><tr><td><code>--poolOptions.threads.useAtomics</code></td><td>使用 Atomics 同步线程。这在某些情况下可以提高性能，但在较旧的 Node 版本中可能会导致 segfault。 (默认值: <code>false</code>)</td></tr><tr><td><code>--poolOptions.vmThreads.isolate</code></td><td>在线程池中隔离测试 (默认值: <code>true</code>)</td></tr><tr><td><code>--poolOptions.vmThreads.singleThread</code></td><td>在单线程内运行测试（默认值：<code>false</code>）</td></tr><tr><td><code>--poolOptions.vmThreads.maxThreads &lt;workers&gt;</code></td><td>运行测试的最大线程数或百分比</td></tr><tr><td><code>--poolOptions.vmThreads.minThreads &lt;workers&gt;</code></td><td>运行测试的最小线程数或百分比</td></tr><tr><td><code>--poolOptions.vmThreads.useAtomics</code></td><td>使用 Atomics 同步线程。这在某些情况下可以提高性能，但在较旧的 Node 版本中可能会导致 segfault。 (默认值: <code>false</code>)</td></tr><tr><td><code>--poolOptions.vmThreads.memoryLimit &lt;limit&gt;</code></td><td>虚拟机线程池的内存限制。如果发现内存泄漏，请尝试调整该值。</td></tr><tr><td><code>--poolOptions.forks.isolate</code></td><td>在 forks pool 中隔离测试 (默认值: <code>true</code>)</td></tr><tr><td><code>--poolOptions.forks.singleFork</code></td><td>单个子进程内运行测试 (default: <code>false</code>)</td></tr><tr><td><code>--poolOptions.forks.maxForks &lt;workers&gt;</code></td><td>运行测试的最大进程数</td></tr><tr><td><code>--poolOptions.forks.minForks &lt;workers&gt;</code></td><td>运行测试的最小进程数</td></tr><tr><td><code>--poolOptions.vmForks.isolate</code></td><td>在 forks pool 中隔离测试 (default: <code>true</code>)</td></tr><tr><td><code>--poolOptions.vmForks.singleFork</code></td><td>在单个子进程内运行测试 (default: <code>false</code>)</td></tr><tr><td><code>--poolOptions.vmForks.maxForks &lt;workers&gt;</code></td><td>运行测试的最大进程数</td></tr><tr><td><code>--poolOptions.vmForks.minForks &lt;workers&gt;</code></td><td>运行测试的最小进程数</td></tr><tr><td><code>--poolOptions.vmForks.memoryLimit &lt;limit&gt;</code></td><td>VM forks pool 的内存限制。如果你观察到内存泄漏问题，可以尝试调整这个值。</td></tr><tr><td><code>--fileParallelism</code></td><td>是否所有测试文件都应并行运行. 使用 <code>--no-file-parallelism</code> 去禁用 (默认值: <code>true</code>)</td></tr><tr><td><code>--maxWorkers &lt;workers&gt;</code></td><td>同时并发执行测试任务的最大线程数或百分比</td></tr><tr><td><code>--minWorkers &lt;workers&gt;</code></td><td>同时并发执行测试任务的最小线程数或百分比</td></tr><tr><td><code>--environment &lt;name&gt;</code></td><td>如果不在浏览器中运行，则指定运行环境 (默认值: <code>node</code>)</td></tr><tr><td><code>--passWithNoTests</code></td><td>未发现测试时通过</td></tr><tr><td><code>--logHeapUsage</code></td><td>在节点中运行时，显示每个测试的堆大小</td></tr><tr><td><code>--allowOnly</code></td><td>允许执行那些被标记为&quot;only&quot;的测试用例或测试套件 (默认值: <code>!process.env.CI</code>)</td></tr><tr><td><code>--dangerouslyIgnoreUnhandledErrors</code></td><td>忽略任何未处理的错误</td></tr><tr><td><code>--shard &lt;shards&gt;</code></td><td>测试套件分区的执行格式为 <code>&lt;index&gt;/&lt;count&gt;</code></td></tr><tr><td><code>--changed [since]</code></td><td>运行受更改文件影响的测试 (默认值: <code>false</code>)</td></tr><tr><td><code>--sequence.shuffle.files</code></td><td>以随机顺序运行文件。如果启用此选项，长时间运行的测试将不会提前开始。 (默认值: <code>false</code>)</td></tr><tr><td><code>--sequence.shuffle.tests</code></td><td>以随机方式运行测试（默认值：<code>false</code>）</td></tr><tr><td><code>--sequence.concurrent</code></td><td>使测试并行运行（默认值：<code>false</code>）</td></tr><tr><td><code>--sequence.seed &lt;seed&gt;</code></td><td>设置随机化种子。如果 --sequence.shuffle（随机序列）是<code>false</code>，则此选项无效。 t 通过 <a href="https://en.wikipedia.org/wiki/Random_seed" target="_blank" rel="noreferrer">&quot;Random Seed&quot; page</a> 查看更多信息</td></tr><tr><td><code>--sequence.hooks &lt;order&gt;</code></td><td>更改钩子的执行顺序。 可接受的值有: &quot;stack&quot;, &quot;list&quot; and &quot;parallel&quot;. 通过 <a href="https://vitest.dev/config/#sequence-hooks" target="_blank" rel="noreferrer"><code>sequence.hooks</code></a> 查看更多信息 (默认值: <code>&quot;parallel&quot;</code>)</td></tr><tr><td><code>--sequence.setupFiles &lt;order&gt;</code></td><td>更改设置文件的执行顺序。可接受的值有 &quot;list&quot; 和 &quot;parallel&quot;。如果设置为&quot;list&quot;，将按照定义的顺序运行设置文件。如果设置为 &quot;parallel&quot;，将并行运行设置文件（默认值：<code>&quot;parallel&quot;</code>）。</td></tr><tr><td><code>--inspect [[host:]port]</code></td><td>启用 Node.js 检查器（默认值：<code>127.0.0.1:9229</code>）</td></tr><tr><td><code>--inspectBrk [[host:]port]</code></td><td>启用 Node.js 检查器并在测试开始前中断</td></tr><tr><td><code>--testTimeout &lt;timeout&gt;</code></td><td>测试的默认超时（毫秒）（默认值：<code>5000</code>）。</td></tr><tr><td><code>--hookTimeout &lt;timeout&gt;</code></td><td>默认钩子超时（以毫秒为单位）（默认值：<code>10000</code>）</td></tr><tr><td><code>--bail &lt;number&gt;</code></td><td>当指定数量的测试失败时停止测试执行（默认值：<code>0</code>）</td></tr><tr><td><code>--retry &lt;times&gt;</code></td><td>如果测试失败，重试特定次数（默认值： <code>0</code>）。</td></tr><tr><td><code>--diff &lt;path&gt;</code></td><td>用于生成差异界面的差异配置的路径</td></tr><tr><td><code>--exclude &lt;glob&gt;</code></td><td>测试中排除的其他文件路径匹配模式</td></tr><tr><td><code>--expandSnapshotDiff</code></td><td>快照失败时显示完整差异</td></tr><tr><td><code>--disableConsoleIntercept</code></td><td>禁用自动拦截控制台日志（默认值：<code>false</code>）</td></tr><tr><td><code>--typecheck.enabled</code></td><td>在测试的同时启用类型检查（默认值：<code>false</code>）</td></tr><tr><td><code>--typecheck.only</code></td><td>仅运行类型检查测试。这将自动启用类型检查（默认值：<code>false</code>）</td></tr><tr><td><code>--typecheck.checker &lt;name&gt;</code></td><td>指定要使用的类型检查器。可用值为 &quot;tsc&quot;和 &quot;vue-tsc &quot;以及一个可执行文件的路径（默认值：<code>tsc</code>）</td></tr><tr><td><code>--typecheck.allowJs</code></td><td>允许对 JavaScript 文件进行类型检查。默认值取自 tsconfig.json</td></tr><tr><td><code>--typecheck.ignoreSourceErrors</code></td><td>忽略源文件中的类型错误</td></tr><tr><td><code>--typecheck.tsconfig &lt;path&gt;</code></td><td>自定义 tsconfig 文件的路径</td></tr><tr><td><code>--project &lt;name&gt;</code></td><td>如果使用 Vitest 工作区功能，则为要运行的项目名称。多个项目可重复此操作： <code>project=1--project=2</code>。也可以使用通配符过滤项目，如 <code>--project=packages*</code> 。</td></tr><tr><td><code>--slowTestThreshold &lt;threshold&gt;</code></td><td>测试速度慢的阈值（以毫秒为单位）（默认值：<code>300</code>）</td></tr><tr><td><code>--teardownTimeout &lt;timeout&gt;</code></td><td>拆卸函数的默认超时（以毫秒为单位）（默认值：<code>10000</code>）</td></tr><tr><td><code>--maxConcurrency &lt;number&gt;</code></td><td>套件中并发测试的最大次数（默认值：`5）</td></tr><tr><td><code>--expect.requireAssertions</code></td><td>要求所有测试至少有一个断言</td></tr><tr><td><code>--expect.poll.interval &lt;interval&gt;</code></td><td>断言的轮询间隔 <code>expect.poll()</code> (默认值: <code>50</code>)</td></tr><tr><td><code>--expect.poll.timeout &lt;timeout&gt;</code></td><td>断言的轮询超时（以毫秒为单位） <code>expect.poll()</code> (默认值: <code>1000</code>)</td></tr><tr><td><code>--printConsoleTrace</code></td><td>始终打印控制台堆栈跟踪</td></tr><tr><td><code>--run</code></td><td>禁用 watch 模式</td></tr><tr><td><code>--no-color</code></td><td>删除控制台输出中的颜色</td></tr><tr><td><code>--clearScreen</code></td><td>在 watch 模式下重新运行测试时清除终端屏幕（默认值：<code>true</code>）。</td></tr><tr><td><code>--standalone</code></td><td>启动 Vitest 而不运行测试。文件过滤器将被忽略，只有在发生变化时才会运行测试。(默认值:<code>false</code>)</td></tr><tr><td><code>--mergeReports [path]</code></td><td>blob 报告目录的路径。如果使用此选项，Vitest 将不会运行任何测试，它将只报告以前记录的测试</td></tr></tbody></table>',1)])])}const h=e(c,[["render",s]]);export{g as __pageData,h as default};
